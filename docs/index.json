[
{
	"uri": "localhost:1313/test/extending_targets/operations/",
	"title": "operations",
	"tags": [],
	"description": "how to write your own custom operations",
	"content": " Defining Custom Operations TODO\n"
},
{
	"uri": "localhost:1313/test/learn/",
	"title": "learn targets",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Learn Targets Sit tight—there\u0026rsquo;s alot to cover. The tutorials in this chapter will cover everything from basic terminology and setup, through advanced configuration and target composition. You will learn all the core usage patterns you will need to work with the framework. By the end, you should be able to write a rich targets-based command-line tool.\nTerminology \u0026amp; Background \u0026raquo;\nThis documentation is still a work-in-progress. Currently, there should be enough here to get you up and running, but some of the documentation for more advanced functionality has not yet been published.\n "
},
{
	"uri": "localhost:1313/test/learn/background/",
	"title": "terminology and background",
	"tags": [],
	"description": "what is a &#34;target&#34; anyhow?",
	"content": " Basic Terminology More terminology will be introduced as you work through the tutorials, but let\u0026rsquo;s start the most basic thing: a target.\nWhat is a \u0026ldquo;target\u0026rdquo;? The short answer: it\u0026rsquo;s a task.\nThe technical answer: At it\u0026rsquo;s core, a target is just a JavaScript function which may return either null, a value, a Promise, a ReadableStream or a pty instance.\nWhat is the framework for? The purpose of the targets framework is to enable you, the author of a CLI tool, to take many small single-purpose functions and safely compose them together along with dynamically sourced config in complex ways by way of a succint declarative syntax.\nThe framework is able to handle readable streams and pty instances. This means that any existing command-line tools you have can easily be incorporated into the workflows you design. There are extensions to make this easy! Keep reading to learn more.\n What is a composition? The main purpose of the framework is to compose targets. If you declare a group of targets and give it a name, we call this a composition. You learn more about this as you work through the tutorials.\nThe Deep End A.K.A. A mysterious example to peak your curiousity Some folks do best with an example. So, without any of the necessary context, let\u0026rsquo;s go straight to the deep end. Below is a fairly complex example of a possible target composition for your consideration. You\u0026rsquo;re not expected to understand what any of this is yet, but if it peaks your curiousity, I encourage you to read on. There\u0026rsquo;s much to explore here, and what you see below won\u0026rsquo;t make much sense until you make it all the way to the end of the docs.\nkind: composition config: git: depth: 1 single-branch: true spec: - '@rebind/name::docker.name' - deploy.select - '@bind/deploy.select.refspec::git.branch' - mktemp - '@bind/mktemp::git.directory' - '@bind/mktemp::docker.context' - git.clone - docker.build - docker.tag - deploy.confirm - '@proceed-when/deploy.confirm.ready' - docker.push - '@bound-to/profile-a::k8s.apply,@bound-to/profile-b::k8s.apply' - '@bound-to/profile-a::k8s.verify,@bound-to/profile-b::k8s.verify'  As you start working through the tutorials in this chapter, most of the examples you\u0026rsquo;ll see use JSON for task compositions. Spoiler alert! As you can see above, Targets supports a special YML syntax. You\u0026rsquo;ll learn about this towards the end of the tutorials.\n Background The Targets Origin Story / A Note From the Author Make was the original build tool. It was originally designed to make configuring, compiling, testing, debugging and running C code easier. It\u0026rsquo;s history is deep coupled with the C programming language. Over time, Make has become useful for all sort of scripting beyond just working with C. In fact, Make was the backbone for a simple docker scheduling tool I wrote a few years ago called powertrain. Targets on the other hand has nothing to do with C, or any other language. Targets started as an attempt to take the best ideas from Make around how to compose tasks and how to source config, to improve upon and modernize these basic ideas. It\u0026rsquo;s ended up being so much more.\nTargets exists because it\u0026rsquo;s a tool that I\u0026rsquo;ve always wanted. It\u0026rsquo;s my passion project. But, I\u0026rsquo;m hoping it can provide value to others as well. Targets was built for me—but anyone with a passion for DevOps and command-line scripting should be able to find new and creative ways to leverage it.\nIn Make, a target is a reference to the \u0026ldquo;target\u0026rdquo; program which you are intending to \u0026ldquo;make\u0026rdquo;, but Make also supports the concept of \u0026ldquo;phony targets\u0026rdquo; which you can define with arbitrary behavior and which can be composed as tasks. It was Make\u0026rsquo;s phony target capabilities which originally inspired this framework, and it\u0026rsquo;s name.\nNext Up: prerequisites\n"
},
{
	"uri": "localhost:1313/test/extending_targets/",
	"title": "extending targets",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Extending Targets Wherein you become familiar with customizing the framework itself.\nTODO\n operations  how to write your own custom operations\n "
},
{
	"uri": "localhost:1313/test/learn/prerequisites/",
	"title": "prerequisites",
	"tags": [],
	"description": "system requirements and assumed knowledge",
	"content": " Targets has not yet been tested on Linux or Windows. It probably works fine on Linux, but there\u0026rsquo;s a good chance it does not work at all on Windows. Addressing this gap in testing is on the roadmap.\n Please ensure you meet the following requirements before getting started:  Node v10.3.0 or higher (v10.8.0 is recommended) Mac OS X  A solid understanding of modern JavaScript syntax will help you follow along in the documentation, but is not strictly required.\n Next Up: installation\n"
},
{
	"uri": "localhost:1313/test/learn/installation/",
	"title": "installation",
	"tags": [],
	"description": "how to add targets as a dependency to your project",
	"content": " To support the experimental TTY-mode (currently in active development), targets has a subdependency on node-pty. node-pty uses some recently deprecated native C++ syntax and as a result you might see a few warnings during installation. You can safely disregard these messages—they are just warnings, not errors. A PR for node-pty is in the works.\n npm install To add targets as a dependency to your project, simply run npm i targets.\ncd ./mycli npm i targets  Next Up: Hello World\n"
},
{
	"uri": "localhost:1313/test/learn/hello_world/",
	"title": "hello world",
	"tags": [],
	"description": "your first target CLI",
	"content": "Let\u0026rsquo;s jump right in. Open up a terminal and complete the steps below. You should have a working targets CLI tool in just a few minutes.\nmkdir mycli cd ./mycli npm init -y npm i targets  Now, copy the code below into a new index.js file.\n#!/usr/bin/env node 'use strict'; const greet = () =\u0026gt; \u0026quot;Hello, World!\u0026quot;; require('targets')({ targets: { greet } });  The above is your first target. As you can see, the most basic target is just a function.\nNext, open your package.json file (this was created for you when you ran npm init -y).\nFind the line with \u0026quot;main\u0026quot;: \u0026quot;index.js\u0026quot;, and right underneath that line, add a new line with \u0026quot;bin\u0026quot;: \u0026quot;./index.js\u0026quot;,.\nSave the file and exit.\nComplete the following steps in your terminal:\nchmod +x ./index.js npm link  Congratulations! You\u0026rsquo;re done with the setting your new CLI tool.\nNow, let\u0026rsquo;s run it. Enter the following in your terminal.\nmycli greet  You should see the following output:\n[greet] Hello, World!  The output from the greet target is prefixed with the target\u0026rsquo;s name. As you add more targets to your tool, this prefix will let you know which output is coming from which target.\nYou can also define a label if you would like to see a different prefix.\nTry editing your index.js file as shown below.\n#!/usr/bin/env node 'use strict'; const greet = () =\u0026gt; \u0026quot;Hello, World!\u0026quot;; greet.label = \u0026quot;Basic Example\u0026quot;; require('targets')({ targets: { greet } });  This time when you run mycli greet you\u0026rsquo;d see the following output:\n[Basic Example] Hello, World!  Every target receives an options object. Let\u0026rsquo;s edit our index.js file again.\n#!/usr/bin/env node 'use strict'; const greet = ({ name = \u0026quot;World\u0026quot; }) =\u0026gt; `Hello, ${name}!`; greet.label = \u0026quot;Basic Example\u0026quot;; require('targets')({ targets: { greet } });  In this case, if you run mycli greet --greet.name Jane you\u0026rsquo;d see the following output:\n[Basic Example] Hello, Jane!  Notice how name has been namespaced with greet in the command line option. Instead of just --name, you had to specify --greet.name. This might seem tedious at first, but you\u0026rsquo;ll understand why this is important as you learn more about the framework.\nNext Up: Config - Part 1\n"
},
{
	"uri": "localhost:1313/test/learn/config_part_1/",
	"title": "config - part 1",
	"tags": [],
	"description": "the basics of how to pass options to your targets",
	"content": "The examples in this section build on what you learned in the \u0026ldquo;Hello, World!\u0026rdquo; tutorial. If you\u0026rsquo;re new to targets, start there.\n Let\u0026rsquo;s make something a little more useful than hello world.\nWe\u0026rsquo;ll reuse what you setup in the \u0026ldquo;Hello, World!\u0026rdquo; tutorial but let\u0026rsquo;s add a couple more dependencies.\nnpm i weather-js mem  Now, copy this into your index.js file.\n#!/usr/bin/env node 'use strict'; const { promisify } = require('util'); const mem = require('mem'); const weatherJs = require('weather-js'); const getWeather = mem((location) =\u0026gt; promisify(weatherJs.find)({ search: location, degreeType: 'F' })); const weatherSky = ({ location }) =\u0026gt; getWeather(location) .then((r) =\u0026gt; r[0].current.skytext); weatherSky.label = \u0026quot;Current Weather\u0026quot;; const weatherTemp = ({ location }) =\u0026gt; getWeather(location) .then((r) =\u0026gt; r[0].current.temperature); weatherSky.label = \u0026quot;Current Temperature\u0026quot;; require('targets')({ targets: { 'weather.sky': weatherSky, 'weather.temp': weatherTemp } });  If you register multiple targets to a given namespace, as we\u0026rsquo;ve done above, they will share config.\nYou can now specify location as --weather.location Chicago for both mycli weather.sky and mycli weather.temp. For example:\nmycli weather.sky --weather.location Chicago [Current Weather] Partly Sunny mycli weather.temp --weather.location Chicago [Current Temperature] 75  This is a good point at which to demonstrate how tasks can be composed, or run together. Consider the following.\nmycli weather.sky weather.temp --weather.location Chicago [Current Weather] Partly Sunny [Current Temperature] 75  We\u0026rsquo;ll talk more about composition later. For now, let\u0026rsquo;s take a look at other ways config can be declared and provided to our targets.\nConsider the following:\n#!/usr/bin/env node 'use strict'; const { promisify } = require('util'); const mem = require('mem'); const weatherJs = require('weather-js'); const getWeather = mem((location) =\u0026gt; promisify(weatherJs.find)({ search: location, degreeType: 'F' })); const weatherSky = ({ location }) =\u0026gt; getWeather(location) .then((r) =\u0026gt; r[0].current.skytext); weatherSky.label = \u0026quot;Current Weather\u0026quot;; const weatherTemp = ({ location }) =\u0026gt; getWeather(location) .then((r) =\u0026gt; r[0].current.temperature); weatherSky.label = \u0026quot;Current Temperature\u0026quot;; const prompts = [ { \u0026quot;name\u0026quot;: \u0026quot;location\u0026quot;, \u0026quot;message\u0026quot;: \u0026quot;Where would you like to know about?\u0026quot;, \u0026quot;default\u0026quot;: \u0026quot;Chicago\u0026quot; } ]; weatherSky.prompts = prompts; weatherTemp.prompts = prompts; require('targets')({ targets: { 'weather.sky': weatherSky, 'weather.temp': weatherTemp } });  In this example, we\u0026rsquo;ve adding some prompts to our weather targets. By doing this, we are declaring what configuration our target requires in order to run, but we\u0026rsquo;re doing so in way which will allow the system to ask for the needed input if it is not provided.\nIf we run the above with mycli weather.sky weather.temp and no additional arguments, Targets will detect that config is missing for these targets and you will be prompted.\nThe output will look something like this.\nmycli weather.sky weather.temp ? [weather.location] Where would you like to know about? Miami [Current Temperature] Mostly Clear [weather.temp] 83  Notice that even though you added these prompts to both of your targets, you only get prompted once. Each prompt is unique by name.\n If the needed config is provided, the user will not be prompted, just as before.\nmycli weather.sky weather.temp --weather.location Chicago [Current Weather] Partly Sunny [Current Temperature] 75   Targets calls this concept \u0026ldquo;naive config\u0026rdquo;. It gives the user the ability to use your target without knowing what config is needed because the target itself knows how to ask for it.\n All prompts are defined as inquirer options. Check the inquirer docs to learn the various ways you\u0026rsquo;ll be able to prompt for config.\nConfig in target goes much deeper than command-line arguments and prompts however. In the next section we\u0026rsquo;ll explore some of the ways that targets handles config files.\nNext Up: Config - Part 2\n"
},
{
	"uri": "localhost:1313/test/learn/config_part_2/",
	"title": "config - part 2",
	"tags": [],
	"description": "more advanced ways of passing options to your targets",
	"content": "The examples in this section build on what you learned in the \u0026ldquo;Config - Part 1\u0026rdquo; tutorial.\n Create a .myclirc file in the project\u0026rsquo;s root directory which contains the following.\n{ \u0026quot;greet\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;Peter\u0026quot; } }  With this file in place, running the greet command from the last section without arguments. It should now resolve config from the file and the user will not be prompted.\nmycli greet [Config Example] Hello, Peter!  Let\u0026rsquo;s move that rc file so that it resides in your user\u0026rsquo;s home directory instead of in the project directory.\nmv ./.myclirc $HOME/.myclirc  Run the command again.\nmycli greet [Config Example] Hello, Peter!  Same effect—it still works. Now, leave the $HOME/.myclirc file in your home directory, but add a copy of it back into your project.\ncp $HOME/.myclirc ./.myclirc  Open the copy in your project directory and change \u0026ldquo;Peter\u0026rdquo; to \u0026ldquo;Jane\u0026rdquo;.\n{ \u0026quot;greet\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;Jane\u0026quot; } }  Run the command again.\nmycli greet [Config Example] Hello, Jane!  The project-level config takes priority.\nBefore, we proceed any further, note that the order of config precedence, from highest precedence to lowest precedence, is as follows:\n command line arguments environment variables prefixed with ${appname}_ (use __ to indicate nested properties. e.g. appname_foo__bar__baz =\u0026gt; foo.bar.baz) .${appname}rc in the project root, or the first found in any parent directories $HOME/.${appname}rc $HOME/.${appname}/config $HOME/.config/${appname} $HOME/.config/${appname}/config /etc/${appname}rc /etc/${appname}/config  All configs will be deeply merged so that one can extend upon another.\nThe logic which handles this config cascade orginally came from the rc module by Dominic Tarr, but it has since been modified and reimplemented in the answers module with additional syntax options and better handling of arrays.\nTo understand how config gets merged, let\u0026rsquo;s do another quick exercise.\nLet\u0026rsquo;s start by adding a new target called logger to our CLI. This target will simply print out the options which it is provided with.\n#!/usr/bin/env node 'use strict'; const logger = (options) =\u0026gt; options; require('targets')({ targets: { logger } });  To test that it\u0026rsquo;s working, run mycli logger --logger.foo. You should see the following output.\nmycli logger --logger.foo [logger] { [logger] \u0026quot;foo\u0026quot;: true [logger] }  Now, create a ./.myclirc in your project directory which contains the following:\n{ \u0026quot;logger\u0026quot;: { \u0026quot;collection\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;foo\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;foo\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;foo\u0026quot; } ] } }  Run mycli logger --logger.collection[1].name bar. You should see this output.\nmycli logger [logger] { [logger] \u0026quot;collection\u0026quot;: [ [logger] { [logger] \u0026quot;name\u0026quot;: \u0026quot;foo\u0026quot; [logger] }, [logger] { [logger] \u0026quot;name\u0026quot;: \u0026quot;bar\u0026quot; [logger] }, [logger] { [logger] \u0026quot;name\u0026quot;: \u0026quot;foo\u0026quot; [logger] } [logger] ] [logger] }  With targets, you can override and amend to almost any value in the config via command-line arguments no matter how complex the config.\nLet\u0026rsquo;s consider a more complex config example. Modify the ./.myclirc in your project directory to look like the following:\n{ \u0026quot;logger\u0026quot;: { \u0026quot;collection\u0026quot;: [ { \u0026quot;people\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;Jane\u0026quot;, \u0026quot;role\u0026quot;: \u0026quot;Developer\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;Peter\u0026quot;, \u0026quot;role\u0026quot;: \u0026quot;Manager\u0026quot; } ] } ] } }  Run mycli logger --logger.collection[0].people[+].name Shana --logger.collection[0].people[+].role Director.\nYou should see the following output:\nmycli logger [logger] { [logger] \u0026quot;collection\u0026quot;: [ [logger] { [logger] \u0026quot;people\u0026quot;: [ [logger] { [logger] \u0026quot;name\u0026quot;: \u0026quot;Jane\u0026quot;, [logger] \u0026quot;role\u0026quot;: \u0026quot;Developer\u0026quot; [logger] }, [logger] { [logger] \u0026quot;name\u0026quot;: \u0026quot;Peter\u0026quot;, [logger] \u0026quot;role\u0026quot;: \u0026quot;Manager\u0026quot; [logger] }, [logger] { [logger] \u0026quot;name\u0026quot;: \u0026quot;Shana\u0026quot;, [logger] \u0026quot;role\u0026quot;: \u0026quot;Director\u0026quot; [logger] } [logger] ] [logger] } [logger] ] [logger] }  This [+] syntax is a special syntax which allows you to push items onto an array in the existing config.\nThere are two other special syntaxes you should become familiar with. Ending an options key with [-] will prepend to an existing array (or \u0026ldquo;unshift\u0026rdquo;), and ending an option key with [\u0026lt;int\u0026gt;,\u0026lt;int\u0026gt;] will splice an existing array.\nSee Array.prototype.splice() for splice documentation if you are not already familiar with it.\n Here\u0026rsquo;s another example, this time using the splice syntax:\nRun mycli logger --logger.collection[0].people[1,0].name Shana --logger.collection[0].people[1,0].role Directory.\nYou should see the following output:\nmycli logger [logger] { [logger] \u0026quot;collection\u0026quot;: [ [logger] { [logger] \u0026quot;people\u0026quot;: [ [logger] { [logger] \u0026quot;name\u0026quot;: \u0026quot;Jane\u0026quot;, [logger] \u0026quot;role\u0026quot;: \u0026quot;Developer\u0026quot; [logger] }, [logger] { [logger] \u0026quot;name\u0026quot;: \u0026quot;Shana\u0026quot;, [logger] \u0026quot;role\u0026quot;: \u0026quot;Director\u0026quot; [logger] }, [logger] { [logger] \u0026quot;name\u0026quot;: \u0026quot;Peter\u0026quot;, [logger] \u0026quot;role\u0026quot;: \u0026quot;Manager\u0026quot; [logger] } [logger] ] [logger] } [logger] ] [logger] }  These special syntax keys work in your config files as well.\nPut the same config as we used above into $HOME/.myclirc. Here it is again for reference:\n{ \u0026quot;logger\u0026quot;: { \u0026quot;collection\u0026quot;: [ { \u0026quot;people\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;Jane\u0026quot;, \u0026quot;role\u0026quot;: \u0026quot;Developer\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;Peter\u0026quot;, \u0026quot;role\u0026quot;: \u0026quot;Manager\u0026quot; } ] } ] } }  Now, open the ./myclirc file in your project directory and populate it with the following:\n{ \u0026quot;logger\u0026quot;: { \u0026quot;collection\u0026quot;: [ { \u0026quot;people[1,0]\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;Shana\u0026quot;, \u0026quot;role\u0026quot;: \u0026quot;Developer\u0026quot; } } ] } }  Now, run mycli logger without any additional arguments.\nYou should see the same effect as when you did this via command-line options.\nCongrats! You now know almost everything targets provides for configuring your targets.\nIn the next section, you\u0026rsquo;ll learn how the framework allows explict config bindings which keep your config dry while maintaining proper boundaries on the functional components of your system.\nNext Up: Bindings\n"
},
{
	"uri": "localhost:1313/test/learn/bindings/",
	"title": "bindings",
	"tags": [],
	"description": "how to use bindings. a first look at target operations",
	"content": " The examples in this section build on what you learned in the \u0026ldquo;Config - Part 2\u0026rdquo; tutorial.\n First, a soapbox about about side-effects You may be wonder why the framework isolates a target\u0026rsquo;s config to a given namespace. Targets imposes this limitation in order to guarantee that your targets are composed without unintended side-effects. Each target represents a single functional component of your system, and each namespace represents the data provider for a single functional domain. This keeps the system in alignment with the single responsibility principle so long as you define each target to do one and only one thing and configure each namespace to have well-defined boundaries.\n When functional components of a system are allowed to reach outside their intended domain, and allowed to implicitly affect other components, it can easily result in unintended and difficult to debug side-effects.\n Sounds safe, but terribly limiting, right? Don\u0026rsquo;t worry! Targets can still share config across namespaces. Your intention to do so simply has to be explicitly declared.\n The framework\u0026rsquo;s config limitations are not about dissallowing side-effects, but about making sure we surface the complexity of inter-related components. It\u0026rsquo;s about making sure that those relationships are explicit and obvious.\n As you\u0026rsquo;ll learn below, Targets provides an elegant solution for doing just this.\nSometimes you will want the result from one target to be fed to the input for another target. Targets supports this via a mechanism called bindings.\nConsider the following:\n#!/usr/bin/env node 'use strict'; const systemName = () =\u0026gt; require('child_process').spawn('whoami'); systemName.label = \u0026quot;System Name\u0026quot;; const githubUser = ({ username }) =\u0026gt; require('axios') .get(`https://api.github.com/users/${username}`) .then(({ data }) =\u0026gt; data); githubUser.silent = true; const greet = ({ name }) =\u0026gt; `Hello, ${name}!`; greet.label = \u0026quot;Greet\u0026quot;; require('targets')({ targets: { 'system.name': systemName, 'github.user': githubUser, greet } });  If you\u0026rsquo;re coding along with the tutorial, you\u0026rsquo;ll need to add axios to your project for the above example code to work (npm i axios).\n Let\u0026rsquo;s run some example commands and use a binding on the targets we\u0026rsquo;ve implemented above\u0026hellip;\nmycli system.name system.name::greet.name greet [System Name] machellerogden [Greet] Hello, machellerogden!  \u0026hellip;and another example\u0026hellip;\nmycli github.user github.user.name::greet.name greet [Greet] Hello, Mac Heller-Ogden!  Here you\u0026rsquo;ll see that the result from one target was \u0026ldquo;bound\u0026rdquo; to the config of another target.\nThe right-side of the binding can use the special array notations you learned about in the previous section: [+], [-], [\u0026lt;int\u0026gt;,\u0026lt;int\u0026gt;].\n Aside from binding results, targets also allows you to \u0026ldquo;rebind\u0026rdquo; config from one namespace to another by prefacing your binding with an @ character. For example\u0026hellip;\nmycli --foo.location Miami @foo.location::weather.location weather.sky  In this example the foo location config value will be copied over to weather.location.\nThis is particularly useful when you are creating composition targets. You\u0026rsquo;ll learn about composition targets more later, but for now consider the following.\nGiven we have a config file which looks like this:\n{ \u0026quot;name\u0026quot;: \u0026quot;myproject\u0026quot; }  \u0026hellip;let\u0026rsquo;s say you have a docker namespace and a k8s namespace target which both want to use this top-level name property. Don\u0026rsquo;t worry about how these targets are implemented—we\u0026rsquo;ll keep this example conceptual.\nFor this scenario, you could write a composition target like so:\n// deploy.js module.exports = [ '@name::docker.name', '@name::k8s.name', 'docker.build', 'docker.push', 'k8s.deploy' ];  When you run your composition target (i.e. mycli deploy), both the docker.build and the k8s.deploy targets will receive the top-level name config property.\nIt\u0026rsquo;s important to understand that bindings are actually just operations. Target has other built-in operations which you\u0026rsquo;ll learn about later, as well as supporting custom operations which you can define yourself.\nIn the examples above, we used a binding shorthand. Bindings have a special short-hand syntax because they are one of the most common operations you\u0026rsquo;ll use as you build your CLI tool.\nLet\u0026rsquo;s see review these examples again, but this time we\u0026rsquo;ll use the long-form syntax.\nThe long-form bind syntax would look like this:\nmycli system.name @bind/system.name::greet.name greet [System Name] machellerogden [Greet] Hello, machellerogden!  mycli github.user @bind/github.user.name::greet.name greet [Greet] Hello, Mac Heller-Ogden!  \u0026hellip;the here is the rebind example, using the long-form syntax:\nmycli --foo.location Miami @rebind/foo.location::weather.location weather.sky  Now that you understand bindings, it\u0026rsquo;s time to learn how to sequence and parallelize target execution, and you\u0026rsquo;ll learn more about target composition.\nNext Up: Composition\n"
},
{
	"uri": "localhost:1313/test/learn/composition/",
	"title": "composition",
	"tags": [],
	"description": "how to compose your targets into workflows",
	"content": "The examples in this section build on what you learned in the \u0026ldquo;Bindings\u0026rdquo; tutorial.\n Targets are run sequentially by default, but when separated by comma they will be invoked in parallel.\nHere\u0026rsquo;s an example of running two targets in parallel:\nmycli weather.sky,weather.temp --weather.location Chicago [Current Temperature] 75 [Current Weather] Partly Sunny  Note the order of the results. Because these were run in parallel the order of the results is non-deterministic.\nTargets is all about composing small, single-purpose targets with various operations and configuration. When you declare a group of targets and give it a name, we call this a composition.\nYou\u0026rsquo;ve already seen a basic composition in a previous example when we learned about bindings. Now, let\u0026rsquo;s explore Targets\u0026rsquo; scheduler and how Targets handles the sequencing and parallelizing of target compositions.\nSet your index.js file to the following:\n#!/usr/bin/env node 'use strict'; const { promisify } = require('util'); const sleep = promisify(setTimeout); const clock = () =\u0026gt; String(Math.floor(Date.now()/1000)).slice(-1); const a = () =\u0026gt; sleep(1000).then(() =\u0026gt; `scheduler demo - ${clock()}`); const b = [ 'a', 'a,a,a', 'a' ]; const c = [ 'b', 'b,b,b', 'b' ]; require('targets')({ targets: { a, b, c } });  Run mycli a.\nYou should see something similar to the following output print after short delay:\n[a] scheduler demo - 7  Now, run mycli b.\nYou should see something similar to the following output print out over the course of a few seconds:\n[a] scheduler demo - 4 [a] scheduler demo - 5 [a] scheduler demo - 5 [a] scheduler demo - 5 [a] scheduler demo - 6  Note how the three lines in the middle all printed at the same time (the counter shows the same number).\nThis demonstrates how the parallelized groups can be nest within greater sequences. As a final demonstration run mycli c.\nOver the course of several seconds your should see something similar to the following output:\n[a] scheduler demo - 6 [a] scheduler demo - 7 [a] scheduler demo - 7 [a] scheduler demo - 7 [a] scheduler demo - 8 [a] scheduler demo - 9 [a] scheduler demo - 9 [a] scheduler demo - 9 [a] scheduler demo - 0 [a] scheduler demo - 0 [a] scheduler demo - 0 [a] scheduler demo - 0 [a] scheduler demo - 0 [a] scheduler demo - 0 [a] scheduler demo - 0 [a] scheduler demo - 0 [a] scheduler demo - 0 [a] scheduler demo - 1 [a] scheduler demo - 1 [a] scheduler demo - 1 [a] scheduler demo - 2 [a] scheduler demo - 3 [a] scheduler demo - 3 [a] scheduler demo - 3 [a] scheduler demo - 4  If you scrutinize the clock output, you will see that parallel groups can be nested within sequences and sequences can be nested in parallel groups to an arbitrary depth. This is obviously a contrived example, but it demonstrates the scheduling capabilities of the framework.\nNow, not all targets output a single line at a single moment in time. Because Targets can return streams, and if you parallelize something with a stream, you will get interleaved results. All lines are prefixed with a label, so this should help you sort out which output is coming from which target.\nLet\u0026rsquo;s take a look at a target which returns a stream.\n#!/usr/bin/env node 'use strict'; const { spawn } = require('child_process'); const tcpdump = () =\u0026gt; spawn('tcpdump', ['-i', 'en0', '-n', '-s', '0']); require('targets')({ targets: { tcpdump } });  Now, when we run sudo mycli tcpdump the output from tcpdump is streamed to the console.\nsudo mycli tcpdump [tcpdump] output here... [tcpdump] output here... [tcpdump] output here... [tcpdump] output here... [tcpdump] output here...  Note that sudo is required for this example because tcpdump needs permission to attach to your network interface.\n If you were to compose this with other streams or asynchrous targets, the output will be interleaved but each line will always be prefixed with the reporting target\u0026rsquo;s label.\nTODO: add interleaved stream output example to docs.\nNext Up: Loaders\n"
},
{
	"uri": "localhost:1313/test/learn/loaders/",
	"title": "loaders",
	"tags": [],
	"description": "using loaders",
	"content": "You can pass a glob or array of globs to Targets.load function if you\u0026rsquo;d like to have dynamically source targets within your project. Using the Targets.load function will also automatically apply any of targets built-in loaders. Additionally, you can pass a second argument to this function with a map of custom loaders to use.\nTODO: what is a loader, how do you create a custom loader, etc.\nNext Up: Project Structure\n"
},
{
	"uri": "localhost:1313/test/learn/project_structure/",
	"title": "project structure",
	"tags": [],
	"description": "recommendations for how to structure your targets projects",
	"content": " Recommended Project Structure / Bootstrapping You can structure your project however you like, however, here is some basic guidance you might find useful.\nIf you define all your targets in a ./targets directory like so:\n./mycli └─┬─┬─ targets/ │ ├─── ip.js │ ├─── memory.js │ └─── tcpdump.js ├─ package.json ├─ index.js └─ .myclirc  Then, in ./index.js you just need to include the following to auto register any new target file modules.\n#!/usr/bin/env node 'use strict'; const targets = require('require-dir')('./targets'); require('targets')({ name: 'mycli', targets });  With this structure in place, so long as each file module inside the ./targets directory exports a function, the filename (minus the extension) will become the target\u0026rsquo;s name.\nUsing Loaders If you are using the Targets.load(\u0026lt;glob\u0026gt;) function, you can gain much more flexibility in you organize things. More on this coming soon.\nTODO: add section about load\nNext Up: More to learn\n"
},
{
	"uri": "localhost:1313/test/learn/more/",
	"title": "more",
	"tags": [],
	"description": "more to explore and learn",
	"content": " More Examples Review the ./examples directory for more examples.\nNext Up: Experimental TTY-mode\n"
},
{
	"uri": "localhost:1313/test/learn/tty_mode/",
	"title": "tty-mode",
	"tags": [],
	"description": "about the experimental tty-mode",
	"content": " EXPERIMENTAL! TTY-mode is NOT complete and is highly-experimental. That said, it is mostly working as of the latest release if you want to give it a go. Use it at your own discretion.\n The interleaved output format is very helpful for logs when using targets on a CI system, such as Jenkins, but it can sometimes be a little hard to follow as a user. Also, what if your target results in an interactive TTY? For these reasons, targets has an experiment TTY-mode which will multiplex parallelized output streams.\nConsider we were to execute two parallel targets which launched a docker TTY like so:\nmycli docker.run,docker.run --docker.tty --docker.interaction --docker.name busybox -- --tty  If you add a -- at the end of your command, any additional arguments will be passed down directly to the framework. For example, for TTY-mode you can add -- --tty at the end of any command. This tells targets to run in \u0026ldquo;tty\u0026rdquo; mode.\n You would then be presented with a multiplexed terminal which looks something like this:\n┌───────────────────────┐┌───────────────────────────────────────────────────────┐ │[docker.run,docker.run]││ │ │ ││[docker] Running: docker run --tty busybox:latest │ │ ││[docker] Running: docker run --tty busybox:latest │ └───────────────────────┘│ │ ┌───────────────────────┐│ │ │ │└───────────────────────────────────────────────────────┘ │docker.run - started │┌─docker────────────────────────────────────────────────┐ │docker.run - started ││/ # │ │ ││ │ │ ││ │ │ ││ │ │ ││ │ │ │└───────────────────────────────────────────────────────┘ │ │┌─docker────────────────────────────────────────────────┐ │ ││/ # │ │ ││ │ │ ││ │ │ ││ │ │ ││ │ └───────────────────────┘└───────────────────────────────────────────────────────┘  To move between the panes, just hit Ctrl-N or Ctrl-P. To exit, hit Ctrl-C or Ctrl-Q.\nGiven your target has returned working TTY, as shown above, you can even interact with the shell inside any of the multiplexed panes.\n"
},
{
	"uri": "localhost:1313/test/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "localhost:1313/test/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": " Contributors Right now, it\u0026rsquo;s mostly been a one-man show, but all PR will be considered. Contributions are welcome!\n.ghContributors{ display:flex; flex-flow: wrap; align-content: flex-start } .ghContributors  div{ width: 50% ; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label{ padding-left: 4px ; } .ghContributors  div span{ font-size: x-small; padding-left: 4px ; }   @machellerogden 149 commits   Prior Art Without the work of many many devs before me, specifically the authors of packages such as rc, minimist and inquirer, this project might have never gotten off the ground. Thank you.\n"
},
{
	"uri": "localhost:1313/test/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "localhost:1313/test/",
	"title": "targets",
	"tags": [],
	"description": "",
	"content": " \nmany small things is the next big thing targets is a task composition and scheduling framework for the command-line\n\nGet Started \u0026raquo; \n"
}]